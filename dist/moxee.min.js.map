{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///moxee.min.js","webpack:///webpack/bootstrap 5640ed4af497423e6259","webpack:///./index.js","webpack:///./angular-fix/index.js","webpack:///./expectControllerToNotMissDependencies.js","webpack:///./invokeQueue.js","webpack:///./stateControllers.js","webpack:///external \"angular\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","harness","invokeQueue","stateControllers","angular","version","window","expectControllerToNotMissDependencies","controller","$injector","locals","getDependencies","func","$inject","isArray","slice","length","STRIP_COMMENTS","ARGUMENT_NAMES","fnStr","toString","replace","result","indexOf","match","isString","get","controllerDeps","isMissing","missingDependencies","filter","dep","isDefined","e","expect","displayName","name","join","to","be","empty","harnessModuleInvokeQueue","ngModule","shouldHarness","harnessedModules","forEach","getComponents","component","attachTestHarnesses","getModuleDependencies","depModule","_invokeQueue","testableComponentTypes","map","type","definition","testedThingsByName","createGenericTestHarness","shouldHarnessFn","requires","ngModuleName","describe","beforeEach","it","inject","ddo","invoke","$scope","$element","$attrs","harnessStateControllers","allStates","mockResolves","state","mockResolve","resolve","key","resolves","parent","data","createControllerTest","extend"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moxee\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"moxee\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moxee\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"moxee\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\t  harness: {\n\t    invokeQueue: __webpack_require__(3),\n\t    stateControllers: __webpack_require__(4)\n\t  }\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t\"use strict\";\n\n\tvar angular = __webpack_require__(5);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar angular = __webpack_require__(1);\n\n\tmodule.exports = expectControllerToNotMissDependencies;\n\n\tfunction expectControllerToNotMissDependencies(controller, $injector, locals) {\n\t  controller = angular.isString(controller) ? $injector.get(controller) : controller;\n\t  var controllerDeps = getDependencies(controller);\n\t  var isMissing = true;\n\t  var missingDependencies = controllerDeps.filter(function (dep) {\n\t    if (angular.isDefined(locals[dep])) {\n\t      return !isMissing;\n\t    }\n\t    try {\n\t      $injector.get(dep);\n\t      return !isMissing;\n\t    } catch (e) {\n\t      return isMissing;\n\t    }\n\t  });\n\t  expect(missingDependencies, \"The controller `\" + (controller.displayName || controller.name || \"anonymous\") + \"` has dependencies not available \" + \"in its module or its module's dependencies. Extra dependencies: \\\"\" + (\"\" + missingDependencies.join(\", \") + \"\\\"\")).to.be.empty;\n\n\t  function getDependencies(func) {\n\t    if (func.$inject) {\n\t      return func.$inject;\n\t    } else if (angular.isArray(func)) {\n\t      return func.slice(0, func.length - 1);\n\t    }\n\t    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\t    var ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n\t    var result = fnStr.slice(fnStr.indexOf(\"(\") + 1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES);\n\t    if (result === null) {\n\t      result = [];\n\t    }\n\t    return result;\n\t  }\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar expectControllerToNotMissDependencies = __webpack_require__(2);\n\tvar angular = __webpack_require__(1);\n\tvar testableComponentTypes = [\"directive\", \"factory\", \"provider\", \"register\"];\n\tvar harnessedModules = {};\n\tvar testedThingsByName = {};\n\n\tmodule.exports = harnessModuleInvokeQueue;\n\n\t// automatically create tests for all registered components\n\n\t// auto-harness components that don't have tests setup\n\t// this helps to enforce modularity\n\tfunction harnessModuleInvokeQueue(ngModule, shouldHarness) {\n\t  if (typeof ngModule === \"string\") {\n\t    ngModule = angular.module(ngModule);\n\t  }\n\t  if (harnessedModules[ngModule.name]) {\n\t    return;\n\t  }\n\t  harnessedModules[ngModule.name] = true;\n\t  angular.forEach(getComponents(ngModule), function (component) {\n\t    return attachTestHarnesses(component, ngModule);\n\t  });\n\t  angular.forEach(getModuleDependencies(ngModule, shouldHarness), function (depModule) {\n\t    harnessModuleInvokeQueue(depModule, shouldHarness);\n\t  });\n\t}\n\n\tfunction getComponents(ngModule) {\n\t  return ngModule._invokeQueue.filter(function (component) {\n\t    return testableComponentTypes.indexOf(component[1]) !== -1;\n\t  }).map(function (component) {\n\t    var type = component[1];\n\t    var name = component[2][0];\n\t    var definition = component[2][1];\n\t    return { name: name, definition: definition, type: type };\n\t  });\n\t}\n\n\tfunction attachTestHarnesses(component, ngModule) {\n\t  if (testedThingsByName[\"component\" + component.name]) {\n\t    return;\n\t  }\n\t  testedThingsByName[\"component\" + component.name] = { component: component, ngModule: ngModule };\n\t  createGenericTestHarness(component, ngModule.name);\n\t}\n\n\tfunction getModuleDependencies(ngModule, shouldHarnessFn) {\n\t  return ngModule.requires.filter(shouldHarnessFn).map(function (name) {\n\t    return angular.module(name);\n\t  });\n\t}\n\n\tfunction createGenericTestHarness(component, ngModuleName) {\n\t  describe(component.type + \" \" + component.name, function () {\n\t    beforeEach(window.module(ngModuleName));\n\n\t    it(\"should not use anything it does not explicitly depend on\", function () {\n\t      // angular will cause the failure we're looking for.\n\t      // So this always passing assertion wont even run if\n\t      // It's depending on something it shouldn't.\n\t      expect(true).to.be[\"true\"];\n\t    });\n\n\t    if (component.type === \"directive\") {\n\t      it(\"should not have a controller that uses anything it should not\", inject(function ($injector) {\n\t        var ddo = $injector.invoke(component.definition);\n\t        if (ddo.controller) {\n\t          expectControllerToNotMissDependencies(ddo.controller, $injector, {\n\t            $scope: {},\n\t            $element: {},\n\t            $attrs: {}\n\t          });\n\t        }\n\t      }));\n\t    }\n\t  });\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// automatically create tests for all controllers\n\t\"use strict\";\n\n\tvar expectControllerToNotMissDependencies = __webpack_require__(2);\n\tvar angular = __webpack_require__(1);\n\n\tmodule.exports = harnessStateControllers;\n\n\tfunction harnessStateControllers(allStates) {\n\t  angular.forEach(allStates, function (state) {\n\t    if (!state.controller) {\n\t      return;\n\t    }\n\t    var resolves = mockResolves(state);\n\t    createControllerTest(state.controller, state.data.ngModule, resolves);\n\t  });\n\n\t  function mockResolves(state) {\n\t    var parent = state;\n\t    var resolves = {};\n\t    while (parent) {\n\t      angular.forEach(parent.resolve, mockResolve);\n\t      parent = parent.data && parent.data.parent;\n\t    }\n\t    return resolves;\n\n\t    function mockResolve(resolve, key) {\n\t      resolves[key] = {};\n\t    }\n\t  }\n\n\t  function createControllerTest(controller, ngModuleName, resolves) {\n\t    if (typeof ngModuleName !== \"string\") {\n\t      ngModuleName = ngModuleName.name;\n\t    }\n\t    describe(\"controller \" + controller.name, function () {\n\t      beforeEach(window.module(ngModuleName));\n\n\t      it(\"should not use anything it does not explicitly depend on\", inject(function ($injector) {\n\t        expectControllerToNotMissDependencies(controller, $injector, angular.extend({ $scope: {} }, resolves));\n\t      }));\n\t    });\n\t  }\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** moxee.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5640ed4af497423e6259\n **/","module.exports = {\n  harness: {\n    invokeQueue: require('./invokeQueue'),\n    stateControllers: require('./stateControllers')\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/","// some versions of angular don't export the angular module properly,\n// so we get it from window in this case.\nvar angular = require('angular');\nif (!angular.version) {\n  angular = window.angular;\n}\nmodule.exports = angular;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./angular-fix/index.js\n **/","const angular = require('./angular-fix');\n\nmodule.exports = expectControllerToNotMissDependencies;\n\nfunction expectControllerToNotMissDependencies(controller, $injector, locals) {\n  controller = angular.isString(controller) ? $injector.get(controller) : controller;\n  const controllerDeps = getDependencies(controller);\n  const isMissing = true;\n  const missingDependencies = controllerDeps.filter(function(dep) {\n    if (angular.isDefined(locals[dep])) {\n      return !isMissing;\n    }\n    try {\n      $injector.get(dep);\n      return !isMissing;\n    } catch(e) {\n      return isMissing;\n    }\n  });\n  expect(missingDependencies,\n    `The controller \\`${controller.displayName || controller.name || 'anonymous'}\\` has dependencies not available ` +\n    `in its module or its module's dependencies. Extra dependencies: \"` +\n    `${missingDependencies.join(', ')}\"`\n  ).to.be.empty;\n\n\n  function getDependencies(func) {\n    if (func.$inject) {\n      return func.$inject;\n    } else if (angular.isArray(func)) {\n      return func.slice(0, func.length - 1);\n    }\n    const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n    const ARGUMENT_NAMES = /([^\\s,]+)/g;\n    const fnStr = func.toString().replace(STRIP_COMMENTS, '');\n    let result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    if(result === null) {\n      result = [];\n    }\n    return result;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./expectControllerToNotMissDependencies.js\n **/","const expectControllerToNotMissDependencies = require('./expectControllerToNotMissDependencies');\nconst angular = require('./angular-fix');\nconst testableComponentTypes = ['directive', 'factory', 'provider', 'register'];\nconst harnessedModules = {};\nconst testedThingsByName = {};\n\nmodule.exports = harnessModuleInvokeQueue;\n\n// automatically create tests for all registered components\n\n// auto-harness components that don't have tests setup\n// this helps to enforce modularity\nfunction harnessModuleInvokeQueue(ngModule, shouldHarness) {\n  if (typeof ngModule === 'string') {\n    ngModule = angular.module(ngModule);\n  }\n  if (harnessedModules[ngModule.name]) {\n    return;\n  }\n  harnessedModules[ngModule.name] = true;\n  angular.forEach(getComponents(ngModule), component => attachTestHarnesses(component, ngModule));\n  angular.forEach(getModuleDependencies(ngModule, shouldHarness), depModule => {\n    harnessModuleInvokeQueue(depModule, shouldHarness);\n  });\n}\n\nfunction getComponents(ngModule) {\n  return ngModule._invokeQueue\n    .filter(component => testableComponentTypes.indexOf(component[1]) !== -1)\n    .map(component => {\n      const type = component[1];\n      const name = component[2][0];\n      const definition = component[2][1];\n      return {name, definition, type};\n    });\n}\n\nfunction attachTestHarnesses(component, ngModule) {\n  if (testedThingsByName['component' + component.name]) {\n    return;\n  }\n  testedThingsByName['component' + component.name] = {component, ngModule};\n  createGenericTestHarness(component, ngModule.name);\n}\n\nfunction getModuleDependencies(ngModule, shouldHarnessFn) {\n  return ngModule.requires\n    .filter(shouldHarnessFn)\n    .map((name) => angular.module(name));\n}\n\nfunction createGenericTestHarness(component, ngModuleName) {\n  describe(component.type + ' ' + component.name, function() {\n    beforeEach(window.module(ngModuleName));\n\n\n    it('should not use anything it does not explicitly depend on', function() {\n      // angular will cause the failure we're looking for.\n      // So this always passing assertion wont even run if\n      // It's depending on something it shouldn't.\n      expect(true).to.be.true;\n    });\n\n    if (component.type === 'directive') {\n      it('should not have a controller that uses anything it should not', inject(function($injector) {\n        const ddo = $injector.invoke(component.definition);\n        if (ddo.controller) {\n          expectControllerToNotMissDependencies(ddo.controller, $injector, {\n            $scope: {},\n            $element: {},\n            $attrs: {}\n          });\n        }\n      }));\n    }\n  });\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./invokeQueue.js\n **/","// automatically create tests for all controllers\nconst expectControllerToNotMissDependencies = require('./expectControllerToNotMissDependencies');\nconst angular = require('./angular-fix');\n\nmodule.exports = harnessStateControllers;\n\nfunction harnessStateControllers(allStates) {\n  angular.forEach(allStates, function(state) {\n    if (!state.controller) {\n      return;\n    }\n    const resolves = mockResolves(state);\n    createControllerTest(state.controller, state.data.ngModule, resolves);\n  });\n\n  function mockResolves(state) {\n    let parent = state;\n    const resolves = {};\n    while(parent) {\n      angular.forEach(parent.resolve, mockResolve);\n      parent = parent.data && parent.data.parent;\n    }\n    return resolves;\n\n    function mockResolve(resolve, key) {\n      resolves[key] = {};\n    }\n  }\n\n  function createControllerTest(controller, ngModuleName, resolves) {\n    if (typeof ngModuleName !== 'string') {\n      ngModuleName = ngModuleName.name;\n    }\n    describe('controller ' + controller.name, function() {\n      beforeEach(window.module(ngModuleName));\n\n      it('should not use anything it does not explicitly depend on', inject(function($injector) {\n        expectControllerToNotMissDependencies(controller, $injector, angular.extend({$scope: {}}, resolves));\n      }));\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./stateControllers.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"moxee.min.js"}