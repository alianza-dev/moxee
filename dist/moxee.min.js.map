{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///moxee.min.js","webpack:///webpack/bootstrap 314c1bd0c17dd62718fd","webpack:///./index.js","webpack:///external \"_\"","webpack:///./expectControllerToNotMissDependencies.js","webpack:///./angular-fix/index.js","webpack:///./invokeQueue.js","webpack:///./stateControllers.js","webpack:///external \"angular\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_6__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","harness","invokeQueue","stateControllers","expectControllerToNotMissDependencies","controller","$injector","locals","getDependencies","func","$inject","_","isArray","slice","length","STRIP_COMMENTS","ARGUMENT_NAMES","fnStr","toString","replace","result","indexOf","match","isString","get","controllerDeps","isMissing","missingDependencies","filter","dep","isUndefined","e","expect","displayName","name","join","to","be","empty","angular","version","window","harnessModuleInvokeQueue","ngModule","shouldHarness","harnessedModules","each","getComponents","component","attachTestHarnesses","getModuleDependencies","depModule","chain","_invokeQueue","contains","testableComponentTypes","map","type","definition","value","testedThingsByName","createGenericTestHarness","shouldHarnessFn","requires","ngModuleName","describe","beforeEach","it","inject","ddo","invoke","$scope","$element","$attrs","harnessStateControllers","allStates","mockResolves","state","mockResolve","resolve","key","resolves","parent","data","createControllerTest","assign"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"_\"), require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"_\", \"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moxee\"] = factory(require(\"_\"), require(\"angular\"));\n\telse\n\t\troot[\"moxee\"] = factory(root[\"_\"], root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"_\"), require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"_\", \"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moxee\"] = factory(require(\"_\"), require(\"angular\"));\n\telse\n\t\troot[\"moxee\"] = factory(root[\"_\"], root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tmodule.exports = {\n\t  harness: {\n\t    invokeQueue: __webpack_require__(4),\n\t    stateControllers: __webpack_require__(5)\n\t  }\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _ = __webpack_require__(1);\n\n\tmodule.exports = expectControllerToNotMissDependencies;\n\n\tfunction expectControllerToNotMissDependencies(controller, $injector, locals) {\n\t  controller = _.isString(controller) ? $injector.get(controller) : controller;\n\t  var controllerDeps = getDependencies(controller);\n\t  var isMissing = true;\n\t  var missingDependencies = _.filter(controllerDeps, function (dep) {\n\t    if (!_.isUndefined(locals[dep])) {\n\t      return !isMissing;\n\t    }\n\t    try {\n\t      $injector.get(dep);\n\t      return !isMissing;\n\t    } catch (e) {\n\t      return isMissing;\n\t    }\n\t  });\n\t  expect(missingDependencies, \"The controller `\" + (controller.displayName || controller.name || \"anonymous\") + \"` has dependencies not available \" + \"in its module or its module's dependencies. Extra dependencies: \\\"\" + (\"\" + missingDependencies.join(\", \") + \"\\\"\")).to.be.empty;\n\n\t  function getDependencies(func) {\n\t    if (func.$inject) {\n\t      return func.$inject;\n\t    } else if (_.isArray(func)) {\n\t      return func.slice(0, func.length - 1);\n\t    }\n\t    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\t    var ARGUMENT_NAMES = /([^\\s,]+)/g;\n\t    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n\t    var result = fnStr.slice(fnStr.indexOf(\"(\") + 1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES);\n\t    if (result === null) {\n\t      result = [];\n\t    }\n\t    return result;\n\t  }\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t\"use strict\";\n\n\tvar angular = __webpack_require__(6);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar expectControllerToNotMissDependencies = __webpack_require__(2);\n\tvar _ = __webpack_require__(1);\n\tvar angular = __webpack_require__(3);\n\tvar testableComponentTypes = [\"directive\", \"factory\", \"provider\", \"register\"];\n\tvar harnessedModules = {};\n\tvar testedThingsByName = {};\n\n\tmodule.exports = harnessModuleInvokeQueue;\n\n\t// automatically create tests for all registered components\n\n\t// auto-harness components that don't have tests setup\n\t// this helps to enforce modularity\n\tfunction harnessModuleInvokeQueue(ngModule, shouldHarness) {\n\t  if (typeof ngModule === \"string\") {\n\t    ngModule = angular.module(ngModule);\n\t  }\n\t  if (harnessedModules[ngModule.name]) {\n\t    return;\n\t  }\n\t  harnessedModules[ngModule.name] = true;\n\t  _.each(getComponents(ngModule), function (component) {\n\t    return attachTestHarnesses(component, ngModule);\n\t  });\n\t  _.each(getModuleDependencies(ngModule, shouldHarness), function (depModule) {\n\t    harnessModuleInvokeQueue(depModule, shouldHarness);\n\t  });\n\t}\n\n\tfunction getComponents(ngModule) {\n\t  return _.chain(ngModule._invokeQueue).filter(function (component) {\n\t    return _.contains(testableComponentTypes, component[1]);\n\t  }).map(function (component) {\n\t    var type = component[1];\n\t    var name = component[2][0];\n\t    var definition = component[2][1];\n\t    return { name: name, definition: definition, type: type };\n\t  }).value();\n\t}\n\n\tfunction attachTestHarnesses(component, ngModule) {\n\t  if (testedThingsByName[\"component\" + component.name]) {\n\t    return;\n\t  }\n\t  testedThingsByName[\"component\" + component.name] = { component: component, ngModule: ngModule };\n\t  createGenericTestHarness(component, ngModule.name);\n\t}\n\n\tfunction getModuleDependencies(ngModule, shouldHarnessFn) {\n\t  return _.chain(ngModule.requires).filter(shouldHarnessFn).map(function (name) {\n\t    return angular.module(name);\n\t  }).value();\n\t}\n\n\tfunction createGenericTestHarness(component, ngModuleName) {\n\t  describe(component.type + \" \" + component.name, function () {\n\t    beforeEach(window.module(ngModuleName));\n\n\t    it(\"should not use anything it does not explicitly depend on\", function () {\n\t      // angular will cause the failure we're looking for.\n\t      // So this always passing assertion wont even run if\n\t      // It's depending on something it shouldn't.\n\t      expect(true).to.be[\"true\"];\n\t    });\n\n\t    if (component.type === \"directive\") {\n\t      it(\"should not have a controller that uses anything it should not\", inject(function ($injector) {\n\t        var ddo = $injector.invoke(component.definition);\n\t        if (ddo.controller) {\n\t          expectControllerToNotMissDependencies(ddo.controller, $injector, {\n\t            $scope: {},\n\t            $element: {},\n\t            $attrs: {}\n\t          });\n\t        }\n\t      }));\n\t    }\n\t  });\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// automatically create tests for all controllers\n\t\"use strict\";\n\n\tvar expectControllerToNotMissDependencies = __webpack_require__(2);\n\tvar _ = __webpack_require__(1);\n\n\tmodule.exports = harnessStateControllers;\n\n\tfunction harnessStateControllers(allStates) {\n\t  _.each(allStates, function (state) {\n\t    if (!state.controller) {\n\t      return;\n\t    }\n\t    var resolves = mockResolves(state);\n\t    createControllerTest(state.controller, state.data.module, resolves);\n\t  });\n\n\t  function mockResolves(state) {\n\t    var parent = state;\n\t    var resolves = {};\n\t    while (parent) {\n\t      _.each(parent.resolve, mockResolve);\n\t      parent = parent.data && parent.data.parent;\n\t    }\n\t    return resolves;\n\n\t    function mockResolve(resolve, key) {\n\t      resolves[key] = {};\n\t    }\n\t  }\n\n\t  function createControllerTest(controller, ngModuleName, resolves) {\n\t    describe(\"controller \" + controller.name, function () {\n\t      beforeEach(window.module(ngModuleName));\n\n\t      it(\"should not use anything it does not explicitly depend on\", inject(function ($injector) {\n\t        expectControllerToNotMissDependencies(controller, $injector, _.assign({ $scope: {} }, resolves));\n\t      }));\n\t    });\n\t  }\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** moxee.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 314c1bd0c17dd62718fd\n **/","module.exports = {\n  harness: {\n    invokeQueue: require('./invokeQueue'),\n    stateControllers: require('./stateControllers')\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"_\"\n ** module id = 1\n ** module chunks = 0\n **/","const _ = require('lodash');\n\nmodule.exports = expectControllerToNotMissDependencies;\n\nfunction expectControllerToNotMissDependencies(controller, $injector, locals) {\n  controller = _.isString(controller) ? $injector.get(controller) : controller;\n  const controllerDeps = getDependencies(controller);\n  const isMissing = true;\n  const missingDependencies = _.filter(controllerDeps, function(dep) {\n    if (!_.isUndefined(locals[dep])) {\n      return !isMissing;\n    }\n    try {\n      $injector.get(dep);\n      return !isMissing;\n    } catch(e) {\n      return isMissing;\n    }\n  });\n  expect(missingDependencies,\n    `The controller \\`${controller.displayName || controller.name || 'anonymous'}\\` has dependencies not available ` +\n    `in its module or its module's dependencies. Extra dependencies: \"` +\n    `${missingDependencies.join(', ')}\"`\n  ).to.be.empty;\n\n\n  function getDependencies(func) {\n    if (func.$inject) {\n      return func.$inject;\n    } else if (_.isArray(func)) {\n      return func.slice(0, func.length - 1);\n    }\n    const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n    const ARGUMENT_NAMES = /([^\\s,]+)/g;\n    const fnStr = func.toString().replace(STRIP_COMMENTS, '');\n    let result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    if(result === null) {\n      result = [];\n    }\n    return result;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./expectControllerToNotMissDependencies.js\n **/","// some versions of angular don't export the angular module properly,\n// so we get it from window in this case.\nvar angular = require('angular');\nif (!angular.version) {\n  angular = window.angular;\n}\nmodule.exports = angular;\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./angular-fix/index.js\n **/","const expectControllerToNotMissDependencies = require('./expectControllerToNotMissDependencies');\nconst _ = require('lodash');\nconst angular = require('./angular-fix');\nconst testableComponentTypes = ['directive', 'factory', 'provider', 'register'];\nconst harnessedModules = {};\nconst testedThingsByName = {};\n\nmodule.exports = harnessModuleInvokeQueue;\n\n// automatically create tests for all registered components\n\n// auto-harness components that don't have tests setup\n// this helps to enforce modularity\nfunction harnessModuleInvokeQueue(ngModule, shouldHarness) {\n  if (typeof ngModule === 'string') {\n    ngModule = angular.module(ngModule);\n  }\n  if (harnessedModules[ngModule.name]) {\n    return;\n  }\n  harnessedModules[ngModule.name] = true;\n  _.each(getComponents(ngModule), component => attachTestHarnesses(component, ngModule));\n  _.each(getModuleDependencies(ngModule, shouldHarness), depModule => {\n    harnessModuleInvokeQueue(depModule, shouldHarness);\n  });\n}\n\nfunction getComponents(ngModule) {\n  return _.chain(ngModule._invokeQueue)\n    .filter(component => _.contains(testableComponentTypes, component[1]))\n    .map(component => {\n      const type = component[1];\n      const name = component[2][0];\n      const definition = component[2][1];\n      return {name, definition, type};\n    })\n    .value();\n}\n\nfunction attachTestHarnesses(component, ngModule) {\n  if (testedThingsByName['component' + component.name]) {\n    return;\n  }\n  testedThingsByName['component' + component.name] = {component, ngModule};\n  createGenericTestHarness(component, ngModule.name);\n}\n\nfunction getModuleDependencies(ngModule, shouldHarnessFn) {\n  return _.chain(ngModule.requires)\n    .filter(shouldHarnessFn)\n    .map((name) => angular.module(name))\n    .value();\n}\n\nfunction createGenericTestHarness(component, ngModuleName) {\n  describe(component.type + ' ' + component.name, function() {\n    beforeEach(window.module(ngModuleName));\n\n\n    it('should not use anything it does not explicitly depend on', function() {\n      // angular will cause the failure we're looking for.\n      // So this always passing assertion wont even run if\n      // It's depending on something it shouldn't.\n      expect(true).to.be.true;\n    });\n\n    if (component.type === 'directive') {\n      it('should not have a controller that uses anything it should not', inject(function($injector) {\n        const ddo = $injector.invoke(component.definition);\n        if (ddo.controller) {\n          expectControllerToNotMissDependencies(ddo.controller, $injector, {\n            $scope: {},\n            $element: {},\n            $attrs: {}\n          });\n        }\n      }));\n    }\n  });\n}\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./invokeQueue.js\n **/","// automatically create tests for all controllers\nconst expectControllerToNotMissDependencies = require('./expectControllerToNotMissDependencies');\nconst _ = require('lodash');\n\nmodule.exports = harnessStateControllers;\n\nfunction harnessStateControllers(allStates) {\n  _.each(allStates, function(state) {\n    if (!state.controller) {\n      return;\n    }\n    const resolves = mockResolves(state);\n    createControllerTest(state.controller, state.data.module, resolves);\n  });\n\n  function mockResolves(state) {\n    let parent = state;\n    const resolves = {};\n    while(parent) {\n      _.each(parent.resolve, mockResolve);\n      parent = parent.data && parent.data.parent;\n    }\n    return resolves;\n\n    function mockResolve(resolve, key) {\n      resolves[key] = {};\n    }\n  }\n\n  function createControllerTest(controller, ngModuleName, resolves) {\n    describe('controller ' + controller.name, function() {\n      beforeEach(window.module(ngModuleName));\n\n      it('should not use anything it does not explicitly depend on', inject(function($injector) {\n        expectControllerToNotMissDependencies(controller, $injector, _.assign({$scope: {}}, resolves));\n      }));\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../~/eslint-loader!./stateControllers.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"moxee.min.js"}